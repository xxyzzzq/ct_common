\documentclass{article}
\usepackage{url}
\usepackage{textcomp}

\begin{document}
\title{Programming Guide for the {\tt ct\_common} Library\\v0.5.1}
\author{Zhiqiang Zhang\\{\tt zhangzq@ios.ac.cn}}
\date{}
\maketitle
\tableofcontents
\section{Introduction}
{\tt ct\_common} is a utility library for developing tools for combinatorial testing (CT),
which is used in \emph{Cascade}, a combinatorial test generation tool.
It provides many useful classes for describing software under test (SUT) models,
and a parser which can parse \emph{Cascade} model files into data structures for
further processing. {\tt ct\_common} contains both high-level classes, which helps
describing complex SUT models more easily, and low-level classes which are more suitable
for computer processing.

{\tt ct\_common} has two sub-libraries:
\begin{itemize}
\item {\tt common}: contains many basic classes for CT;
\item {\tt file\_parse}: the parser interface.
\end{itemize}

\section{Integrating into Your Developing \mbox{Environment}}
Here we provide guides for integrating {\tt ct\_common} into your project.
Both the two libraries depend on the {\tt boost} library (only header files are needed),
so you need to make sure the boost header files are included in your include libraries.

The {\tt file\_parse} library depends on a lexical analyzer generator {\tt Quex} and a parser
generator GNU {\tt Bison}. We customized the build rules, so that you don't need to install
{\tt Quex} and {\tt Bison} if you do not modify the parser and generator. The generated lexer
and parser are distributed along with the source package. However if you have modified the source
lexer code or the parser code, the build rules will rebuild the lexer or parser. In this way
you need to install {\tt Quex} or {\tt Bison} and make sure they are in your environment variable
{\tt PATH}. The recommended versions are Bison 2.7 (or higher) and Quex 0.61.1 (or higher).
If you encounter compilation problems for the lexer or parser, you might need to check their versions
first. Besides, the original version of {\tt Quex} has a compilation issue
\footnote{\url{http://sourceforge.net/p/quex/bugs/279/}} (which is okay for some
compilers, but some compiler will report an error). You need to do the following modification to your
installation of {\tt Quex}:
\begin{itemize}
\item In file {\tt quex/code\_base/analyzer/member/constructor.i}, line 119:

{\tt p\_input\_stream == std::cin} $\rightarrow$  {\tt p\_input\_stream == \&std::cin}.
\end{itemize}

If you use {\tt file\_parse}, you need to add additional preprocessor definitions to your project:
\begin{verbatim}
QUEX_OPTION_STRANGE_ISTREAM_IMPLEMENTATION
QUEX_OPTION_ASSERTS_WARNING_MESSAGE_DISABLED
\end{verbatim}

\subsection{Using {\tt ct\_common} in Linux and Mac OS X}
The source package of {\tt ct\_common} comes with a {\tt configure} script generated by GNU autotools.
You can install {\tt ct\_common} in the following way:
\begin{itemize}
\item Change current directory to the directory of the extracted source package;
\item Run {\tt ./configure};
\item Run {\tt make};
\item Run {\tt sudo make install}.
\end{itemize}
Thus the headers and libraries are installed in your {\tt /usr/local} directories.

Or else if your project uses autotools, you can put the extracted source package as a sub-directory
your project (remove the version number of the directory so it becomes {\tt ct\_common}), and then add
{\tt ct\_common} into the {\tt AC\_CONFIG\_SUBSTRS} statement in your {\tt configure.in} file.

\subsection{Using {\tt ct\_common} in Microsoft Visual Studio}
We provide project files for Microsoft Visual Studio 2008. The files are in
{\tt <package\_dir>/build/vc2008/ct\_common}, you can add the solution or single projects into your
solution, and then you can use the libraries.

Note that your project should use Unicode character set, or compilation errors may occur.

\section{Design Overview}
All the classes of {\tt ct\_common} are included in namespace {\tt ct}.
\subsection{Sub-library {\tt common}}
The classes of {\tt common} are included in namespace {\tt ct::common}.
Some important high-level classes are:
\begin{itemize}
\item {\tt ParamSpec}: base class for parameter information;
\item {\tt Strength}: base class for covering strength;
\item {\tt Seed}: base class for seeds;
\item {\tt TreeNode}: base class for expressions;
\item {\tt Constraint}: base class for Boolean expressions;
\item {\tt Exp}: base class for numeric expressions and string expressions;
\item {\tt SUTModel}: a struct containing lists of {\tt ParamSpec}, {\tt Strength},
    {\tt Seed}, {\tt Constraint}.
\end{itemize}

Some low-level classes are:
\begin{itemize}
\item {\tt PVPair}: parameter-value pair;
\item {\tt Tuple}: a parameter combination;
\item {\tt TuplePool}: a pool of parameter combinations;
\item {\tt EvalType}: the results of evaluating Boolean, numeric and string expressions;
\item {\tt RawStrength}: low-level representation for covering strength.
\end{itemize}

\subsection{Sub-library {\tt file\_parse}}
{\tt file\_parse} depend on {\tt common}. All the classes are included in name space {\tt ct}.
Some important high-level classes are:
\begin{itemize}
\item {\tt lexer}: the lexer converting input streams into tokens;
\item {\tt parser}: the parser converting tokens into data structures of {\tt common};
\item {\tt common::assembler}: the assembler classes which directly assembles data structures of
    {\tt common}.
\end{itemize}

\section{A Simple Example}
Here we give an example to show how to use the parser.
Suppose we want to parse the input file into internal data structures,
and print the following information about the model:
\begin{itemize}
\item Number of parameters;
\item Number of strengths;
\item Number of seeds;
\item Number of constraints;
\item Number of target combinations;
\item Number of forbidden combinations;
\end{itemize}

A program to achieve these goals is as follows (the example is included in the source package):

{\scriptsize
\begin{verbatim}
#include <iostream>
#include <fstream>
#include <map>

#include <ct_common/file_parse/ct_lexer.hpp>
#include <ct_common/file_parse/ct_parser.tab.hpp>
#include <ct_common/file_parse/assembler.h>
#include <ct_common/file_parse/err_logger_cerr.h>
#include <ct_common/common/sutmodel.h>
#include <ct_common/common/tuplepool.h>

using namespace ct;
using namespace ct::common;

int main(int argc, char* argv[]) {
  std::string file_name;
  if (argc < 2) {
    std::cerr << "please specify the file name" << std::endl;
    return 1;
  }
  file_name = argv[1];
  std::ifstream infile;
#ifdef _MSC_VER
  // handling file names with non-ascii characters
  wchar_t *wcstring = new wchar_t[file_name.size()+1];
  setlocale(LC_ALL, ".OCP");
  mbstowcs(wcstring, file_name.c_str(), file_name.size()+1);
  infile.open(wcstring);
  delete[] wcstring;
  setlocale(LC_ALL, "");
#else  // _MSC_VER
  infile.open(file_name.c_str());
#endif  // _MSC_VER
  if (!infile.is_open()) {
    std::cerr << "cannot open the input file" << std::endl;
    return 1;
  }
  SUTModel sut_model;
  Assembler assembler;
  try {
    ct::lexer lexer(&infile);
    assembler.setErrLogger(boost::shared_ptr<ErrLogger>(new ErrLogger_Cerr()));
    yy::ct_parser parser(lexer,
                         sut_model.param_specs_,
                         sut_model.strengths_,
                         sut_model.seeds_,
                         sut_model.constraints_,
                         assembler);
    parser.parse();
  } catch (std::runtime_error e) {
    std::cerr << e.what() << std::endl;
  } catch (...) {
    std::cerr << "unhandled exception when parsing input file" << std::endl;
    std::cerr << "exiting" << std::endl;
    return 1;
  }
  if (assembler.numErrs() > 0) {
    std::cerr << assembler.numErrs() << " errors in the input file, exiting" << std::endl;
    return 2;
  }
  std::cout << "successfully parsed the input file" << std::endl;
  std::cout << "# parameters:  " << sut_model.param_specs_.size() << std::endl;
  std::cout << "# strengths:   " << sut_model.strengths_.size() << std::endl;
  std::cout << "# seeds:       " << sut_model.seeds_.size() << std::endl;
  std::cout << "# constraints: " << sut_model.constraints_.size() << std::endl;

  std::vector<RawStrength> raw_strengths;
  TuplePool tuple_pool;
  for (int i = 0; i < sut_model.strengths_.size(); ++i) {
    attach_2_raw_strength(sut_model.strengths_[i], raw_strengths);
  }
  for (int i = 0; i < raw_strengths.size(); ++i) {
    Tuple tuple;
    for (int j = 0; j < raw_strengths[i].size(); ++j) {
      tuple.push_back(PVPair(raw_strengths[i][j], 0));
    }
    if (tuple.size() <= 0) {
      continue;
    }
    do {
      tuple_pool.add(tuple);
    } while (tuple.to_the_next_tuple(sut_model.param_specs_));
  }
  std::cout << "# target combinations: " << tuple_pool.size() << std::endl;

  TuplePool forbidden_tuple_pool;
  for (int i = 0; i < sut_model.constraints_.size(); ++i) {
    std::map<int, bool> rel_pids;
    sut_model.constraints_[i]->touch_pids(sut_model.param_specs_, rel_pids);
    Tuple tuple;
    for (std::map<int, bool>::const_iterator iter = rel_pids.begin();
        iter != rel_pids.end(); iter++) {
      tuple.push_back(PVPair(iter->first, 0));
    }
    do {
      EvalType_Bool result = sut_model.constraints_[i]->Evaluate(
                                    sut_model.param_specs_, tuple);
      if (!result.is_valid_ || !result.value_) {
        forbidden_tuple_pool.add(tuple);
      }
    } while (tuple.to_the_next_tuple_with_ivld(sut_model.param_specs_));
  }
  std::cout << "# forbidden combinations: " << forbidden_tuple_pool.size() << std::endl;
  return 0;
}
\end{verbatim}
}

\section{Useful Contents}
\subsection*{Cascade}
{\tt ct\_common} is strongly related to the Cascade combinatorial test generator.
The features in this library are designed for general purpose, but the interfaces
are specially customized for Cascade. So many high-level features are not compatible
with some existing methods or algorithms, but they can be easily translated into corresponding
low-level representations, which are compatible with most existing methods or algorithms.
Due to time limit, we don't have enough time to write the detailed documentation
for classes in {\tt ct\_common}. Thus we strongly recommend you to read the Cascade user manual
before using our library. You can find the according words for most
features of {\tt ct\_common} in the Cascade manual. The web page is as follows:
{\tt http://lcs.ios.ac.cn/\texttildelow zhangzq/ct-toolkit.html}.

\subsection*{GNU Autotools}
These include autoconf, automake, libtool, etc. Understanding how they work
will help you integrating {\tt ct\_common} into your project in Linux or Mac OS X.
Useful materials can be found at \url{http://en.wikipedia.org/wiki/GNU_build_system}.

\subsection*{Quex}
If you want to add more functions to the parser, you may need to modify the lexer and rebuild it.
Thus you need to follow the instructions for Quex.
The materials can be found at \url{http://quex.sourceforge.net}.

\subsection*{Bison}
If you want to add more functions to the parser, you may need to modify the lexer and rebuild it.
Thus you need to follow the instructions for Bison.
The materials can be found at \url{https://www.gnu.org/software/bison/}.

\end{document}

